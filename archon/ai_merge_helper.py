"""
AI Merge Helper module for improving merged code quality.
This module provides functions to refine code generated by merging multiple templates.
"""

import os
import asyncio
from typing import Dict, List, Any

async def refine_code_with_ai(model, file_path: str, template_names: List[str]) -> str:
    """
    Refine code using AI to improve quality, readability, and maintainability.
    
    Args:
        model: The AI model to use for refinement
        file_path: Path to the file to refine
        template_names: Names of the templates that were merged
        
    Returns:
        Path to the refined file
    """
    # Read the file content
    with open(file_path, 'r', encoding='utf-8') as f:
        file_content = f.read()
    
    # Skip empty files or files that are too small
    if len(file_content) < 10:
        print(f"\n[DEEP LOG] Skipping AI refinement for {os.path.basename(file_path)} (too small)")
        return file_path
    
    filename = os.path.basename(file_path)
    print(f"\n[DEEP LOG] Performing AI refinement for {filename}...")
    
    # Prepare prompt for AI refinement
    refinement_prompt = f"""You are an expert code refiner. You need to improve the following merged code file.
    This file was generated by merging code from multiple templates: {', '.join(template_names)}.
    
    Your task is to refine this code to make it more coherent, efficient, and maintainable.
    Focus on:
    1. Removing redundancies and duplications
    2. Ensuring consistent naming and style
    3. Improving error handling and robustness
    4. Ensuring all functionality from the original templates is preserved
    5. Making the code more readable and maintainable
    
    Original merged file ({filename}):
    ```
{file_content}
```
    
    Provide the refined version of this file. Only output the refined code, nothing else.
    """
    
    try:
        # Use the model directly for refinement
        refined_content = await model.generate(refinement_prompt)
        
        # Write the refined content back to the file
        refined_filepath = file_path.replace('.', '_refined.')
        with open(refined_filepath, 'w', encoding='utf-8') as f:
            f.write(refined_content)
        
        print(f"\n[DEEP LOG] Successfully refined {filename} -> {os.path.basename(refined_filepath)}")
        return refined_filepath
    except Exception as e:
        print(f"\n[DEEP LOG] Error during AI refinement of {filename}: {str(e)}")
        # If refinement fails, keep the original file
        return file_path

async def refine_merged_files(model, output_paths: Dict[str, str], template_names: List[str]) -> Dict[str, str]:
    """
    Refine all merged files using AI.
    
    Args:
        model: The AI model to use for refinement
        output_paths: Dictionary mapping filenames to file paths
        template_names: Names of the templates that were merged
        
    Returns:
        Dictionary mapping filenames to refined file paths
    """
    refined_files = {}
    
    for filename, filepath in output_paths.items():
        if filename.endswith(('.py', '.json')) and os.path.exists(filepath):
            refined_filepath = await refine_code_with_ai(model, filepath, template_names)
            refined_files[filename] = refined_filepath
    
    return refined_files

async def apply_refined_files(refined_files: Dict[str, str], output_paths: Dict[str, str]) -> Dict[str, str]:
    """
    Apply refined files by replacing the original files.
    
    Args:
        refined_files: Dictionary mapping filenames to refined file paths
        output_paths: Dictionary mapping filenames to original file paths
        
    Returns:
        Updated output_paths dictionary
    """
    for filename, filepath in refined_files.items():
        # Replace the original file with the refined version
        if os.path.exists(filepath) and filepath != output_paths[filename]:
            # Backup the original file
            backup_path = output_paths[filename] + '.bak'
            os.rename(output_paths[filename], backup_path)
            os.rename(filepath, output_paths[filename])
            print(f"\n[DEEP LOG] Replaced {filename} with refined version (original backed up as {os.path.basename(backup_path)})")
    
    return output_paths

async def ai_refine_merged_code(model, workbench_dir: str, output_paths: Dict[str, str], template_names: List[str]) -> Dict[str, str]:
    """
    Main function to refine merged code using AI.
    
    Args:
        model: The AI model to use for refinement
        workbench_dir: Path to the workbench directory
        output_paths: Dictionary mapping filenames to file paths
        template_names: Names of the templates that were merged
        
    Returns:
        Updated output_paths dictionary
    """
    print(f"\n[DEEP LOG] Starting AI-driven refinement of merged code...")
    try:
        # Use the AI code refiner module to refine the merged files
        refined_files = await refine_merged_files(model, output_paths, template_names)
        
        # Apply the refined files (replace originals with refined versions)
        if refined_files:
            output_paths = await apply_refined_files(refined_files, output_paths)
        
        print(f"\n[DEEP LOG] AI-driven refinement completed.")
    except Exception as e:
        print(f"\n[DEEP LOG] Error during AI-driven refinement: {str(e)}")
        # If AI refinement fails, we still return the original merged files
    
    return output_paths
