# AI-Driven Template Merging

This feature enhances the `merge_agent_templates` functionality by adding AI-powered code refinement to improve the quality of merged code.

## Overview

The AI-driven merge process follows a two-step approach:

1. **Rule-based Merging (Baseline)**: The existing `merge_agent_templates` function uses regular expressions and string manipulation to parse and combine code components from different templates.

2. **AI Refinement**: After the rule-based merge is complete, an AI model is used to refine the merged code, improving its coherence, readability, and maintainability.

## How to Use

### Option 1: Using the `use_ai_merge` Parameter

The `merge_agent_templates` function now accepts a new parameter `use_ai_merge` that enables AI-driven merging:

```python
result = await merge_agent_templates(
    ctx=ctx,
    template_ids=[1, 2],
    custom_name="My Merged Agent",
    custom_description="An agent with multiple capabilities",
    use_ai_merge=True  # Enable AI-driven merge
)
```

### Option 2: Using the Standalone AI Refinement Module

You can also use the AI refinement module separately after performing a rule-based merge:

```python
from archon.ai_merge_helper import ai_refine_merged_code

# Step 1: Perform rule-based merge
merge_result = await merge_agent_templates(ctx, template_ids=[1, 2])

# Step 2: Perform AI refinement
workbench_dir = merge_result.get("output_directory")
output_paths = {filename: os.path.join(workbench_dir, filename) for filename in merge_result.get("generated_files", [])}
template_names = ["Template 1", "Template 2"]

refined_output_paths = await ai_refine_merged_code(
    model=ctx.model,
    workbench_dir=workbench_dir,
    output_paths=output_paths,
    template_names=template_names
)
```

## Example Script

See the `merge_with_ai_refinement.py` script for a complete example of how to use the AI-driven merge functionality.

## Benefits of AI-Driven Merging

1. **Improved Code Quality**: The AI model can identify and fix issues that rule-based merging might miss, such as redundancies, inconsistencies, and potential bugs.

2. **Better Integration**: The AI can ensure that components from different templates work together seamlessly.

3. **Enhanced Readability**: The AI can improve code organization, naming conventions, and documentation.

4. **Robustness**: The two-step approach ensures that even if AI refinement fails, you still have a working baseline from the rule-based merge.

## Implementation Details

The AI-driven merge functionality is implemented in two main components:

1. **`ai_merge_helper.py`**: Contains functions for refining code using AI models.

2. **`merge_agent_templates` function**: Updated to support AI-driven merging through the `use_ai_merge` parameter.

The AI refinement process:

1. Takes the code generated by the rule-based merge
2. Sends it to an AI model with a prompt that explains the refinement task
3. Writes the refined code to new files
4. Replaces the original files with the refined versions (keeping backups)

## Troubleshooting

If you encounter issues with the AI-driven merge:

1. **Check Model Access**: Ensure your AI model (e.g., OpenAI API) is properly configured and accessible.

2. **Review Logs**: Look for error messages in the logs to identify specific issues.

3. **Fallback to Rule-Based Merge**: If AI refinement fails, you can still use the rule-based merge by setting `use_ai_merge=False`.

4. **Examine Backup Files**: If the AI refinement produces unexpected results, you can restore the original files from the `.bak` backups.
