var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ServerBuilder_tools, _ServerBuilder_resources, _ServerBuilder_prompts;
// Based on https://github.com/wong2/litemcp/
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { CallToolRequestSchema, ErrorCode, GetPromptRequestSchema, ListPromptsRequestSchema, ListResourcesRequestSchema, ListToolsRequestSchema, McpError, ReadResourceRequestSchema, } from "@modelcontextprotocol/sdk/types.js";
import { zodToJsonSchema } from "zod-to-json-schema";
export class ServerBuilder {
    constructor(name = "mcp-server", version = "1.0.0") {
        this.name = name;
        this.version = version;
        _ServerBuilder_tools.set(this, void 0);
        _ServerBuilder_resources.set(this, void 0);
        _ServerBuilder_prompts.set(this, void 0);
        __classPrivateFieldSet(this, _ServerBuilder_tools, [], "f");
        __classPrivateFieldSet(this, _ServerBuilder_resources, [], "f");
        __classPrivateFieldSet(this, _ServerBuilder_prompts, [], "f");
    }
    setupHandlers(server) {
        this.setupErrorHandling(server);
        if (__classPrivateFieldGet(this, _ServerBuilder_tools, "f").length) {
            this.setupToolHandlers(server);
        }
        if (__classPrivateFieldGet(this, _ServerBuilder_resources, "f").length) {
            this.setupResourceHandlers(server);
        }
        if (__classPrivateFieldGet(this, _ServerBuilder_prompts, "f").length) {
            this.setupPromptHandlers(server);
        }
    }
    setupErrorHandling(server) {
        server.onerror = (error) => {
            console.error("[MCP Error]", error);
        };
        process.on("SIGINT", async () => {
            await server.close();
            process.exit(0);
        });
    }
    setupToolHandlers(server) {
        server.setRequestHandler(ListToolsRequestSchema, async () => {
            return {
                tools: __classPrivateFieldGet(this, _ServerBuilder_tools, "f").map((tool) => {
                    return {
                        name: tool.name,
                        description: tool.description,
                        inputSchema: tool.parameters
                            ? zodToJsonSchema(tool.parameters)
                            : undefined,
                    };
                }),
            };
        });
        server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const tool = __classPrivateFieldGet(this, _ServerBuilder_tools, "f").find((tool) => tool.name === request.params.name);
            if (!tool) {
                throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`);
            }
            let args = undefined;
            if (tool.parameters) {
                const parsed = tool.parameters.safeParse(request.params.arguments);
                if (!parsed.success) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: `Invalid ${request.params.name} arguments: ${parsed.error.message}`,
                            },
                        ],
                        isError: true,
                    };
                }
                args = parsed.data;
            }
            let result;
            try {
                result = await tool.execute(args);
            }
            catch (error) {
                return {
                    content: [{ type: "text", text: `Error: ${error}` }],
                    isError: true,
                };
            }
            if (typeof result === "string") {
                return {
                    content: [{ type: "text", text: result }],
                };
            }
            return {
                content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
            };
        });
    }
    setupResourceHandlers(server) {
        server.setRequestHandler(ListResourcesRequestSchema, async () => {
            return {
                resources: __classPrivateFieldGet(this, _ServerBuilder_resources, "f").map((resource) => {
                    return {
                        uri: resource.uri,
                        name: resource.name,
                        mimeType: resource.mimeType,
                    };
                }),
            };
        });
        server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
            const resource = __classPrivateFieldGet(this, _ServerBuilder_resources, "f").find((resource) => resource.uri === request.params.uri);
            if (!resource) {
                throw new McpError(ErrorCode.MethodNotFound, `Unknown resource: ${request.params.uri}`);
            }
            let result;
            try {
                result = await resource.load();
            }
            catch (error) {
                throw new McpError(ErrorCode.InternalError, `Error reading resource: ${error}`, {
                    uri: resource.uri,
                });
            }
            return {
                contents: [
                    {
                        uri: resource.uri,
                        mimeType: resource.mimeType,
                        ...result,
                    },
                ],
            };
        });
    }
    setupPromptHandlers(server) {
        server.setRequestHandler(ListPromptsRequestSchema, async () => {
            return {
                prompts: __classPrivateFieldGet(this, _ServerBuilder_prompts, "f").map((prompt) => {
                    return {
                        name: prompt.name,
                        description: prompt.description,
                        arguments: prompt.arguments,
                    };
                }),
            };
        });
        server.setRequestHandler(GetPromptRequestSchema, async (request) => {
            const prompt = __classPrivateFieldGet(this, _ServerBuilder_prompts, "f").find((prompt) => prompt.name === request.params.name);
            if (!prompt) {
                throw new McpError(ErrorCode.MethodNotFound, `Unknown prompt: ${request.params.name}`);
            }
            const args = request.params.arguments;
            if (prompt.arguments) {
                for (const arg of prompt.arguments) {
                    if (arg.required && !(args && arg.name in args)) {
                        throw new McpError(ErrorCode.InvalidRequest, `Missing required argument: ${arg.name}`);
                    }
                }
            }
            let result;
            try {
                result = await prompt.load(args);
            }
            catch (error) {
                throw new McpError(ErrorCode.InternalError, `Error loading prompt: ${error}`);
            }
            return {
                description: prompt.description,
                messages: [
                    {
                        role: "user",
                        content: { type: "text", text: result },
                    },
                ],
            };
        });
    }
    addTool(tool) {
        __classPrivateFieldGet(this, _ServerBuilder_tools, "f").push(tool);
        return this;
    }
    addResource(resource) {
        __classPrivateFieldGet(this, _ServerBuilder_resources, "f").push(resource);
        return this;
    }
    addPrompt(prompt) {
        __classPrivateFieldGet(this, _ServerBuilder_prompts, "f").push(prompt);
        return this;
    }
    build() {
        const capabilities = {};
        if (__classPrivateFieldGet(this, _ServerBuilder_tools, "f").length) {
            capabilities.tools = {};
        }
        if (__classPrivateFieldGet(this, _ServerBuilder_resources, "f").length) {
            capabilities.resources = {};
        }
        if (__classPrivateFieldGet(this, _ServerBuilder_prompts, "f").length) {
            capabilities.prompts = {};
        }
        const server = new Server({ name: this.name, version: this.version }, { capabilities });
        this.setupHandlers(server);
        return server;
    }
}
_ServerBuilder_tools = new WeakMap(), _ServerBuilder_resources = new WeakMap(), _ServerBuilder_prompts = new WeakMap();
